<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Unlocking HTTP Security Nirvana: Zero to Hero in 45 Minutes</title>
    <link rel="stylesheet" href="slide.css">
    <script src="slide.js"></script>
  </head>
  <body class="slide-16x9">
    <pre id="slide">
      # Unlocking HTTP Security Nirvana:
      # Zero to Hero in 45 Minutes
      &mdash; Jamie Taylor

      # Before We Start
      - Let's thank the organisers
      - And you all

      # Emoji Use
      - üí¨ Quote
      - ‚ö†Ô∏è Key point
      - üí≠ Something to think about
      - üí° Background information
      - üìù Key takeaway

      # üí¨ Ancient Wisdom
        Wonderful teachings exist -
        The sword is unfathomable
      &mdash; Yamaoka Tesshu
      <!-- Do not think that
           This is all there is.
           More and more
           Wonderful teachings exist -
           The sword is unfathomable
      -->

      # üí≠ Is HTTPS Enough?
      You've deployed an HTTPS certificate
      Your site shows the padlock icon
      .
      *Is your application secure?*
      <!-- Spoiler alert: No! HTTPS is like locking your front door but leaving
           all the windows open. It encrypts data in transit, but doesn't protect
           against XSS, clickjacking, MIME sniffing attacks, and many other
           browser-based vulnerabilities. Security headers are those window locks. -->

      # ‚ö†Ô∏è What You'll Learn Today
      - What HTTP headers are and why they matter
      - OWASP and the Secure Headers project
      - How to add secure headers manually
      - How OwaspHeaders.Core simplifies everything
      - Where to find AI-friendly documentation

      # üí¨ The OWASP Vision
      "No more insecure software"
      .
      &mdash; Open Worldwide Application Security Project

      # üí° What Are HTTP Headers?
      Metadata sent between client and server
      Key-value pairs in HTTP messages
      .
        Accept: application/json
        Content-Type: text/html
        User-Agent: Mozilla/5.0
      <!-- Think of HTTP headers like the envelope information on a letter: not
           the letter content itself, but instructions about how to handle it.
           Headers tell browsers and servers things like "what format is this in?"
           or "how should you process this?" -->

      # üí° Two Types of Headers
      *Request Headers*: Browser ‚Üí Server
        Cookie: session_id=abc123
        Accept-Language: en-GB
      .
      *Response Headers*: Server ‚Üí Browser
        Content-Type: text/html
        Set-Cookie: session_id=abc123

      # ‚ö†Ô∏è Response Headers for Security
      Server tells browser *how* to behave securely
      .
      - Only use HTTPS connections
      - Don't allow iframe embedding
      - Block untrusted scripts
      - Clear data on logout

      # üí° Try It Yourself
      Open DevTools (F12)
      Navigate to Network tab
      Refresh the page
      Click any request ‚Üí Headers
      .
      *You're looking at HTTP headers right now!*
      <!-- This is a great interactive moment. Pause here and let people actually
           do this. Walk around if you can and see if anyone needs help. The more
           hands-on experience they get, the better they'll understand.
           If you can't get people to do it, open https://dotnetcore.show/ and show
           them -->

      # üí≠ What About Users?
      What if headers could:
      - Prevent clickjacking attacks?
      - Block malicious scripts?
      - Force encrypted connections?
      .
      *They can. Let's explore how.*

      # üí° OWASP
      *Open Worldwide Application Security Project*
      .
      Nonprofit foundation
      Dedicated to software security
      Since 2001

      # üí° OWASP Community
      250+ local chapters worldwide
      Tens of thousands of members
      .
      *Free, vendor-neutral resources*
      Open-source and Creative Commons licensing

      # üí° OWASP Secure Headers Project
      Community-led initiative
      Describes HTTP response headers for security
      .
      *Raises awareness and promotes best practices*
      <!-- The OWASP Secure Headers Project is at:
           https://owasp.org/www-project-secure-headers/
           This is THE authoritative source for HTTP security headers. It's
           maintained by security professionals worldwide and regularly updated
           as new threats emerge and browser capabilities evolve. -->

      # ‚ö†Ô∏è The Problem
      Security headers are well-known
      *But inconsistently implemented*
      .
      Implementation varies dramatically across organisations
      Many sites miss critical protections

      # üí° The Solution
      Best-practice guidance for security headers
      Which headers to implement
      Which headers to remove
      .
      *Authoritative, community-vetted standards*

      # üí° Strict-Transport-Security
      Forces browsers to use HTTPS only
      .
        Strict-Transport-Security: max-age=31536000; includeSubDomains
      .
      *One year of HTTPS-only connections*
      <!-- Also known as HSTS (HTTP Strict Transport Security)
           OWASP ref: https://owasp.org/www-project-secure-headers/#strict-transport-security
           Metaphor: Think of this like a bouncer at a club who refuses to let anyone
           in through the sketchy back door (HTTP) and forces everyone to use the
           secure main entrance (HTTPS). Once a browser sees this header, it won't
           even ATTEMPT an HTTP connection for the specified time period (max-age).
           The includeSubDomains directive means this applies to all subdomains too,
           like www.example.com, api.example.com, etc. -->

      # ‚ö†Ô∏è Prevents Downgrade Attacks
      HTTP ‚Üí HTTPS
      .
      Attackers can't force unencrypted connections
      Man-in-the-middle attacks blocked
      .
      *Even on insecure networks*

      # üí° X-Frame-Options
      Controls whether pages can be embedded in iframes
      .
        X-Frame-Options: DENY
        X-Frame-Options: SAMEORIGIN
      <!-- OWASP ref: https://owasp.org/www-project-secure-headers/#x-frame-options
           Metaphor: This is like saying "my art can't be displayed inside
           someone else's picture frame." DENY means no one can frame your page,
           SAMEORIGIN means only your own site can frame it.
           Note: This is being superseded by Content-Security-Policy's frame-ancestors
           directive, but it's still widely supported and worth including for older
           browsers. -->

      # ‚ö†Ô∏è Prevents Clickjacking
      *Clickjacking*: Tricking users into clicking invisible frames
      .
      Attacker overlays your site in hidden iframe
      User thinks they're on your site
      Actually clicking attacker's buttons
      .
      X-Frame-Options: DENY stops this attack
      <!-- Real-world example: Imagine an attacker creates a page with a fake
           "Click here to win a prize!" button. Underneath, invisible, is an
           iframe of your banking site with a "Transfer ¬£1000" button positioned
           exactly where the prize button appears. The user clicks for a prize
           but actually authorizes a transfer. X-Frame-Options prevents your
           banking site from being loaded in that iframe at all. -->

      # üí° X-Content-Type-Options
      Prevents MIME type sniffing
      .
        X-Content-Type-Options: nosniff
      .
      *Browsers must respect declared Content-Type*
      <!-- OWASP ref: https://owasp.org/www-project-secure-headers/#x-content-type-options
           Metaphor: Think of this as enforcing truth in labeling. Without this,
           a browser might say "this file says it's text/plain, but it LOOKS like
           JavaScript to me, so I'll execute it as JavaScript!" That's dangerous.
           With nosniff, the browser is forced to trust the label: if you say it's
           text/plain, it will be treated as text/plain, period. No guessing games. -->

      # ‚ö†Ô∏è Enforces Content-Type
      Without this header:
      Browser guesses file type from content
      text/plain could be interpreted as JavaScript
      .
      *MIME sniffing enables XSS attacks*
      <!-- Attack scenario: An attacker uploads a file to your site (maybe a profile
           picture upload). The file is actually JavaScript disguised with a .txt
           extension. Your server says "Content-Type: text/plain" but old IE browsers
           would look at the content and say "that looks like JavaScript!" and execute
           it. Modern browsers still do some MIME sniffing, so nosniff closes this hole. -->

      # üí° Content-Security-Policy
      Restricts which resources can load
      .
        Content-Security-Policy: default-src 'self'
      .
      *Most powerful security header*
      <!-- OWASP ref: https://owasp.org/www-project-secure-headers/#content-security-policy
           Metaphor: CSP is like a security guard with a allowlist at an exclusive
           event. Every script, style, image, or other resource that wants to run
           on your page must be on the approved list. If it's not, it gets bounced.
           default-src 'self' means "only load resources from my own domain."
           You can get much more granular: script-src, style-src, img-src, etc.
           This is THE most powerful defence against XSS (Cross-Site Scripting). Even
           if an attacker manages to inject malicious JavaScript into your HTML, CSP
           will prevent it from executing. It is powerful, but can easily break your website. -->

      # ‚ö†Ô∏è Mitigates XSS Attacks
      *Cross-Site Scripting (XSS)*: Injecting malicious scripts
      .
      CSP allowlist blocks unauthorised scripts
      Even if attacker injects code, browser won't run it
      .
      *Defence in depth*

      # üí≠ CSP Complexity Warning
      *Most complex header to configure*
      .
      Page-specific requirements
      Resource-specific allowances
      Nonce or hash-based scripting
      .
      Requires thoughtful design
      <!-- CSP is powerful but can break your site if misconfigured. Common issues:
           - Blocking your own inline scripts (use nonces or hashes)
           - Blocking CDN resources you actually need
           - Breaking third-party widgets (social media embeds, analytics, etc.)
           Start with Content-Security-Policy-Report-Only to test without breaking
           things. Monitor the violation reports, then switch to enforcement mode.
           Real talk: Getting CSP right can take weeks for a complex application.
           Don't let perfect be the enemy of good - start strict and loosen as needed.
           It's like using a chainsaw to spread butter on toast: it's doable, but someone
           is going to lose an arm. -->

      # üí° Cross-Origin-Opener-Policy
      Isolates browsing contexts
      .
        Cross-Origin-Opener-Policy: same-origin
      .
      Prevents cross-origin attacks on window references
      <!-- OWASP ref: https://owasp.org/www-project-secure-headers/#cross-origin-opener-policy
           Metaphor: Imagine you open a popup window to another site. Without COOP,
           that popup can reach back through window.opener and access your original
           page. COOP breaks that connection - it's like cutting the cord between
           two browser tabs so they can't talk to each other unless they're from
           the same origin.
           This works with COEP to enable "cross-origin isolation" which is required
           for some powerful browser features like SharedArrayBuffer (used for
           high-performance apps). -->

      # üí° Cross-Origin-Embedder-Policy
      Controls cross-origin resource embedding
      .
        Cross-Origin-Embedder-Policy: require-corp
      .
      Works with COOP for process isolation
      <!-- OWASP ref: https://owasp.org/www-project-secure-headers/#cross-origin-embedder-policy
           COEP requires that all resources loaded by your page either come from
           your origin OR explicitly opt-in to being embedded via CORS headers
           (specifically Cross-Origin-Resource-Policy: cross-origin).
           Think of it as: "I only want resources that have given me explicit
           permission to use them." This prevents side-channel attacks like Spectre
           where attackers could potentially read cross-origin data.
           Warning: This can break third-party resources (images, scripts) that
           don't send proper CORS headers. Test thoroughly! -->

      # üí° Referrer-Policy
      Controls how much referrer information is shared
      .
        Referrer-Policy: strict-origin-when-cross-origin
      <!-- OWASP ref: https://owasp.org/www-project-secure-headers/#referrer-policy
           When you click a link from page A to page B, the browser sends a "Referer"
           header (yes, misspelled in the HTTP spec!) telling page B where you came from.
           Metaphor: It's like leaving a trail of breadcrumbs everywhere you go on the
           web. Referrer-Policy lets you control how detailed those breadcrumbs are.
           strict-origin-when-cross-origin (recommended) means:
           - Same-origin: Send the full URL
           - Cross-origin HTTPS‚ÜíHTTPS: Send just the origin (https://example.com)
           - HTTPS‚ÜíHTTP: Send nothing (downgrade, not secure)
           Other options: no-referrer (send nothing), same-origin (only within your site) -->

      # ‚ö†Ô∏è Privacy and Security
      Referrer headers can leak sensitive information:
      - Internal URLs
      - Session tokens in query strings
      - User navigation patterns
      .
      *Referrer-Policy limits exposure*
      <!-- Real-world example: User visits:
           https://yoursite.com/reset-password?token=secret123
           They click a link to another site. Without Referrer-Policy, that other
           site receives the FULL URL including the password reset token!
           Another issue: Analytics companies can track users across sites by
           collecting referrer data. Limiting referrers helps user privacy. -->

      # üí° Clear-Site-Data
      Removes cached browser data
      .
        Clear-Site-Data: "cache", "cookies", "storage"
      <!-- OWASP ref: https://owasp.org/www-project-secure-headers/#clear-site-data
           Metaphor: This is the "nuclear option" for cleaning up after yourself.
           When the user logs out, this header tells the browser "delete EVERYTHING
           related to this site."
           Types of data cleared:
           - "cache": HTTP cache, service worker caches
           - "cookies": All cookies for this origin
           - "storage": localStorage, sessionStorage, IndexedDB, etc.
           - "*": Everything (use with caution!)
           Typically sent on logout endpoints. -->

      # ‚ö†Ô∏è Secure Logout Flows
      User logs out
      Cached data could leak to next user
      .
      *Clear-Site-Data removes everything*
      .
      Critical for shared devices
      <!-- Scenario: User logs into online banking on a library computer. They log
           out, but their data is still in localStorage, cookies are still set,
           cached pages might contain sensitive info.
           Next person uses the same browser. Uh oh.
           Clear-Site-Data on the logout endpoint prevents this. The browser wipes
           everything the moment logout completes. Essential for public/shared devices. -->

      # ‚ö†Ô∏è Remove Information Disclosure
        Server: Apache/2.4.41 (Ubuntu)
        X-Powered-By: PHP/7.4.3
      .
      *Don't advertise your tech stack to attackers*
      .
      Removal is as important as addition
      <!-- Security through obscurity isn't real security, BUT there's no reason to
           make an attacker's job easier.
           If I know you're running .NET Framework 3.5, I can look up CVEs (Common
           Vulnerabilities and Exposures) for that specific version. Same with .NET 5
           or anything else.
           Metaphor: It's like having your house locks visible from the street with
           the brand name and model number clearly displayed. A burglar can research
           exactly how to pick that specific lock.
           Remove or obfuscate these headers. In ASP.NET and ASP.NET Core, suppress the
           X-Powered-By and Server headers. In Apache/nginx, configure them to not send
           version info. -->

      # üí≠ How Do We Implement These?
      Eight security headers
      Multiple configuration options
      Precise syntax required
      .
      *Let's see how this works in code*

      # ‚ö†Ô∏è Manual Configuration Challenges
      - Verbose middleware code
      - Easy to misconfigure values
      - Difficult to maintain
      - Need to research correct syntax
      .
      *Demo time: Let's see the pain points*

      # Demo 1: Manual Header Implementation
      Fresh ASP.NET Core minimal API
      Add security headers manually
      .
      *Pay attention to the code volume*
      <!-- Demo prep:
           - Have a fresh ASP.NET Core project ready (dotnet new web)
           - Show the basic Program.cs with app.MapGet("/", () => "Hello World!")
           - Add middleware to set headers one by one
           - Show how verbose it gets
           - Point out the string-based values (typo prone!)
           - Show in browser DevTools that headers are present
           The goal is to show the pain before showing the solution. -->

      # [LIVE DEMO]
      Adding headers manually in middleware
      .
        app.Use(async (context, next) =>
        {
          context.Response.Headers.Add("X-Frame-Options", "DENY");
          context.Response.Headers.Add("X-Content-Type-Options", "nosniff");
          context.Response.Headers.Add("Strict-Transport-Security", "max-age=31536000; includeSubDomains");
          // ... more headers
          await next();
        });

      # ‚ö†Ô∏è Pain Points Observed
      - 2 hardcoded strings per header
      - Typo risk
      - No validation or type safety
      - Easy to forget headers
      - Hard to update across projects
      .
      *There must be a better way*
      <!-- Really emphasize the pain here:
           - Show that you need to look up the exact syntax for each header
           - One typo and the header is silently ignored
           - When OWASP updates recommendations, you need to manually update every project
           - No IntelliSense or compiler help
           - Copying and pasting between projects leads to drift
           This is the "pain" that motivates the solution you're about to show. -->

      # üí≠ Imagine...
      What if all those headers
      Could be added with
      .
      *One line of code?*

      # üí° OwaspHeaders.Core
      NuGet package for ASP.NET Core
      Implements OWASP Secure Headers recommendations
      .
      *Secure by default*
      <!-- Full disclosure: This is my package! I created it because I was tired of
           manually configuring security headers across multiple projects.
           The package:
           - Implements all OWASP recommended headers
           - Uses sensible defaults based on OWASP guidance
           - Provides a fluent API for customization
           - Automatically removes information disclosure headers
           - Gets updated when OWASP recommendations change
           - Fully open source on GitHub
           NuGet: https://www.nuget.org/packages/OwaspHeaders.Core/
           GitHub: https://github.com/GaProgMan/OwaspHeaders.Core -->

      # ‚ö†Ô∏è One Line. All Headers.
      Replace dozens of lines
      With a single method call
      .
        app.UseSecureHeadersMiddleware();
      .
      *Includes all recommended headers with best-practice values*

      # üí° Maintained with OWASP Standards
      Package updates when recommendations change
      No code changes required
      .
      *Stay secure automatically*

      # Demo 2: The One-Line Solution
      Same ASP.NET Core project
      Replace manual headers
      Install OwaspHeaders.Core
      .
      *Watch the transformation*
      <!-- Demo prep:
           - Take the project from Demo 1 (with all the manual headers)
           - dotnet add package OwaspHeaders.Core
           - Delete all the manual middleware code
           - Add app.UseSecureHeadersMiddleware(...)
           - Show in browser that all headers are still there (and maybe more!)
           - Point out how much simpler the code is
           - Show that you get compile-time checking and IntelliSense
           This is the "wow" moment of the talk. -->

      # [LIVE DEMO]
      Install OwaspHeaders.Core
      .
        dotnet add package OwaspHeaders.Core

      # [LIVE DEMO]
      Replace manual middleware
      .
        // Before: 20+ lines of manual headers
        // After:
        app.UseSecureHeadersMiddleware();

      # [LIVE DEMO]
      Inspect headers in browser DevTools
      .
      ‚úÖ X-Frame-Options
      ‚úÖ X-Content-Type-Options
      ‚úÖ Strict-Transport-Security
      ‚úÖ Content-Security-Policy (default)
      ‚úÖ ... and more

      # ‚ö†Ô∏è Victory Achieved
      All headers configured correctly
      Zero configuration errors
      One line of code
      .
      *From dozens of lines to one*

      # üí° CSP Support Included
      OwaspHeaders.Core handles CSP too
      .
        var config = SecureHeadersMiddlewareConfiguration
          .BuildDefaultConfiguration();
        config.UseContentSecurityPolicy(cspBuilder);

      # üí≠ CSP Requires Thought
      Content-Security-Policy is powerful
      But page-specific configuration needed
      .
      Default: 'self' only
      Production: Customised per application
      .
      *Package provides helpers, not magic*
      <!-- Important to set expectations here: OwaspHeaders.Core can't magically
           know what your CSP should be. Every application is different.
           The default CSP (default-src 'self') is VERY restrictive:
           - No inline scripts (<script>alert('hi')</script> won't work)
           - No inline styles
           - No external resources (CDNs, Google Fonts, etc.)
           This will likely break your app! That's intentional - it forces you to
           think about what scripts and resources you ACTUALLY need.
           The package provides a fluent API to customize CSP, but you need to
           understand your app's requirements first. -->

      # üí° CSP Best Practice
      OwaspHeaders.Core provides:
      - CSP builder API
      - Type-safe configuration
      - Validation helpers
      .
      *You provide the security policy decisions*

      # üí° Documentation
      https://gaprogman.github.io/OwaspHeaders.Core/
      .
      Complete API reference
      Configuration examples
      Security best practices

      # ‚ö†Ô∏è NEW: AI-Friendly Documentation
      https://gaprogman.github.io/OwaspHeaders.Core/llms-full.txt
      .
      *Single-file format for coding assistants*
      .
      Claude, ChatGPT, GitHub Copilot, etc.
      <!-- This is a relatively new addition! I created a single TXT file containing
           the entire documentation in a format optimized for LLMs.
           Why? Because AI coding assistants work best when they can ingest complete
           documentation in one go. Traditional web docs spread across multiple pages
           require multiple fetches and context switching.
           The llms-full.txt file contains:
           - All API documentation
           - Configuration examples
           - Best practices
           - Common patterns
           - Troubleshooting tips
           You can give Claude/ChatGPT the URL and ask it to help you configure
           OwaspHeaders.Core for your specific use case. It's surprisingly effective! -->

      # üí° Example AI Prompt
        "Use the documentation at
        https://gaprogman.github.io/OwaspHeaders.Core/llms-full.txt
        to configure OwaspHeaders.Core with a strict CSP
        that allows scripts only from my domain and images from https://chester.dev"
      .
      *AI reads the doc, writes the code*

      # üìù Key Takeaway 1
      HTTPS alone is *not* enough for security
      .
      Security headers provide defence in depth
      Browser-level protection
      .
      *Implement them today*
      <!-- This is the foundational message: HTTPS is necessary but not sufficient.
           Defence in depth means multiple layers of security. If one layer fails,
           others are still protecting you:
           - HTTPS protects data in transit
           - Security headers protect against browser-based attacks
           - Input validation protects against injection
           - Authentication protects against unauthorized access
           - etc.
           Security headers are a low-effort, high-impact layer. No excuse not to use them. -->

      # üìù Key Takeaway 2
      OWASP provides authoritative guidance
      Secure Headers project is community-vetted
      .
      *Free, vendor-neutral, trusted*
      <!-- Why trust OWASP?
           - 20+ years of security expertise
           - Community of thousands of security professionals
           - No vendor bias or commercial agenda
           - Transparent, open-source approach
           - Regularly updated based on real-world threats
           When your boss asks "why should we implement this?", you can point to
           OWASP as the industry-standard authority on application security. -->

      # üìù Key Takeaway 3
      OwaspHeaders.Core simplifies implementation
      One line replaces dozens
      Maintained with OWASP standards
      .
      *Security should be easy*

      # üìù Key Takeaway 4
      Start securing your applications today
      .
        dotnet add package OwaspHeaders.Core
        app.UseSecureHeadersMiddleware();
      .
      *Two commands. Maximum security.*
      <!-- Call to action! Don't let people walk out thinking "that was interesting"
           without actually implementing it.
           Emphasize how EASY this is:
           - Takes literally 2 minutes to add
           - No configuration required to get started
           - Works with all ASP.NET Core apps (.NET 8+)
           - Can be added to existing apps without breaking changes
           - Free and open source
           If you're not using ASP.NET Core, the concepts still apply - look for
           similar packages/middleware in your framework, or implement manually
           using the OWASP guidance. -->

      # Thank You!
      Questions?
      .
      .
      .
      https://gaprogman.github.io/OwaspHeaders.Core/
      @GaProgMan (Bluesky)
      https://rjj-software.co.uk/
      <!-- Common questions to be ready for:
           - Q: "Does this work with .NET Framework?" A: No, only ASP .NET Core on supported platforms (i.e. .NET 8 onwards)
           - Q: "Will this break my existing app?" A: Unlikely, but test CSP carefully
           - Q: "What about other languages/frameworks?" A: Concepts are universal,
                check for similar libraries or implement manually
           - Q: "How often should I update the package?" A: Check for updates quarterly
                or when OWASP releases new guidance
           - Q: "Can I customize individual headers?" A: Yes! Fluent API for everything
           - Q: "What about performance impact?" A: Negligible - just adding headers
           - Q: "Do I need all these headers?" A: Start with all, remove only if
                you have a specific reason (rare)
      -->

      # Jamie Taylor
      - Microsoft MVP (four years running) for Developer Technologies
      - Creator of OwaspHeaders.Core
      - Host of The Modern .NET Show
      - Advocate for secure-by-default practices
      <!-- Presentation tips:
           - Total time: 45 minutes (leave 10 min for Q&A)
           - Pace: Don't rush the demos - they're the highlight
           - Energy: Keep it upbeat but not overwhelming
           - Interaction: Pause after key points to let them sink in
           - Stories: Real-world examples resonate more than theory
           - Humour: Security can be dry - keep it light where appropriate
           - Practice: Run through demos multiple times to avoid hiccups
           - Backup plan: Have screenshots ready in case live demo fails
           - Remember: Your goal is to make security ACCESSIBLE, not intimidating
      -->
    </pre>
  </body>
</html>
